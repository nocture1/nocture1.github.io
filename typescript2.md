# TypeScriptの学習を阻害する共通点
前述の共通点と、TypeScriptではどのように対策できるかを紹介します。  
この共通点とは「Primitive Obsessionの知見が足りなかった」です。

## Primitive Obsessionとは？
オブジェクト型指向のアンチパターンです。  
「プログラミング言語で用意している型しか使わない」という状況を指します。  
これにより生じる問題点をまず取り上げます。

### 1. 型が持つ仕様が流出する

以下は電話をかけるシンプルなコードです。

```ts
/**
 * `validTeleophoneNumber` を事前に呼んでください。
 */
function ring(telephoneNumber string) {}
```

まず見える問題として、 `ring` に引き渡す値に検証処理をパスしたことを強制できないことです。

```ts
// 💀 validTelephoneNumber を呼ばずに呼び出せる
ring("xxx")
```

コメントは開発者間のルールに過ぎず、開発者が「事前に検証処理を呼び出す」ことを意識する必要があります。  
そして、検証処理の呼び出しを忘れると、バグとして表出します。

また、文字列型では「検証処理は呼び出し済なのか」、「検証処理はいつ呼び出したのか」が明確でないのも問題です。  
プログラムの至るところに検証処理が生まれてしまいます。

たとえば、電話番号型という「検証処理をコンストラクタに持つ」型を用意すれば、  
このインスタンスは常に検証処理をパスしていることが保証されます。

```ts
class TelephoneNumber {
    private value: string;
    constructor(value: string) {
        if (validTelephoneNumber(value)) {
            this.value = value;
        } else {
            throw new Error("不正な電話番号です");
        }
    }
}
```

文字列型の場合に検証処理が濫用されるのは、  
電話番号が持つべき仕様（電話番号という形式、特徴）を型に込められないためです。  
このため、型の利用側（外部）で形式チェックを行うことになります。  
総合すると、基本型を使うことでデータが持つ仕様が外部に流出すると言えます。

> ⚡  
> この仕様とは、データが持つべき特徴です。  
> 電話番号であれば電話番号という形式を満たすことと言えますし、  
> システム上空文字を許さないデータであれば、空文字を除いた文字列型である必要があります。

### 2. データの表現力が喪失する

先ほどのコードを再掲します。
以下のコードで引数 `telephoneNumber` はどのような特徴があるでしょうか。

```ts
/**
 * `validTeleophoneNumber` を事前に呼んでください。
 */
function ring(telephoneNumber string) {}
```

システム・モジュールにおいて `telephoneNumber` はどのような役割を果たすでしょうか。  
また、この引数が持つべき特徴（電話番号の形式）は分かるでしょうか。  
おそらく、漠然と電話番号であるということしか分かりません。  
ハイフンを許容するのか、市外局番しか許さないのか…これでは伝わりません。  
周囲のコードを読んだり、仕様書を確認する必要があります。

> ⚡  
> 関数名や変数名がいい加減な場合、この作業はもっと苦痛になります。

これも値の型が基本型であることが問題です。  
電話番号がシステムとしてなんらかの役割を果たしている以上、  
`string` という無味乾燥な型ではなく、 `TelephoneNumber` などの型であるのが自然と言えます。  
総合して、基本型を使うことでデータの表現力が喪失すると言えます。

### Primitive Obsessionの対策シーン
Primitive Obsessionが起きうる場面と対策する機能を紹介します。  
易しいトピックから紹介していますが、独自の構成上入門サイトよりも難しい内容になります。

#### 1. 値の候補が有限個の場合 → ユニオン型を使う
データがとる値の種類が有限個の場合、ユニオン型を利用することで対策できます。  
実行環境をお持ちの方は、 `number` に変えて `1 | 2 | 3 | 4` を書き換え、  
最後の `else` ブランチの変数を確認してみましょう。

```ts
function show(n: number) {
    if (n === 1) {
        
    } else if (n === 2) {

    } else {
        // n の型
        n
    }
}
```

> ⚡  
> オブジェクトリテラルやNull可能性が現れる場合、慎重に扱う必要があります。  
> Discriminant UnionやMake Illegal States Unrepresentableなどが該当するトピックです。

#### 2. 類似の型構造が乱立している ⇒ 型演算子やMapped Typesなどを使う
定数や型が持つ構造を参照して、新たに型を生み出すことができます。  
型演算子、Lookup Types、Mapped Typesなどがあります。

```ts
type User = ...

// Omit<User, 'id'> 型Userから id プロパティを除外した型を
function post(user: Omit<User, 'id'>) {}
```

これらの機能を活用することで既存の構造を再利用できるため、型のDRYが実現できるのが主な目的です。  
ただし、「参照する型を表明する」ことにより、型の表現力を獲得したメリットがあります。

```ts
type User = { id: number, name: string };

function getById(id: User['id']) {}
```

`getById` の引数の型は単なる `number` ではなく、 `User.id` と言えます。  
どのような値を渡せばよいのかは一目瞭然です。  
これが `number` であった場合、この関数を利用しているコードを見て、  
「どんな値を渡せばよいか」確認するのではないでしょうか？

#### 3. 型と仕様が分離している　⇒ 型に情報を込める構文を利用する
シーンごとに活用できる構文がケースバイケースで、難しいカテゴリです。  
TypeScriptでは型引数の制約、条件型、inferキーワードを中心に活用します。  
現実的には、良く扱うシーンだけ押さえておいて、妥協することになると思います。

```ts
const dict = {
    ja: '日本',
    en: '英国'
};

// 引数の型は 'ja' | 'en' になる
function show<Domain extends typeof keyof dict>(domain: Domain) {}
```

このほか、前段で取り上げた電話番号型についても紹介します。
